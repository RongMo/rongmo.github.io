[{"title":"移动端常见的一些兼容性问题","url":"/移动端常见的一些兼容性问题/","content":"\n随着手机的普及，移动端的开发也成了一个重要的方向，但由于设备的不统一会造成一些兼容性问题，\n\n##### 1、安卓浏览器看背景图片，有些设备会模糊。\n\n用同等比例的图片在PC机上很清楚，但是手机上很模糊，原因是什么呢？\n\n经过研究，是devicePixelRatio作怪，因为手机分辨率太小，如果按照分辨率来显示网页，这样字会非常小，所以苹果当初就把iPhone 4的960 * 640分辨率，在网页里只显示了480 * 320，这样devicePixelRatio＝2。现在android比较乱，有1.5的，有2的也有3的。\n\n<!--more-->\n\n想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况都是用2倍）。例如一个div的宽高是100 * 100，背景图必须得200 * 200，然后background-size:contain;，这样显示出来的图片就比较清晰了。\n\n代码可以如下：\n\n```css\nbackground:url(../images/icon/all.png) no-repeat center center;\n\n-webkit-background-size:50px 50px;\n\nbackground-size: 50px 50px;display:inline-block; width:100%; height:50px;  \n\n```\n\n\n\n或者指定 background-size:contain;都可以，大家试试！\n\n#####2、图片加载\n\n若您遇到图片加载很慢的问题，对这种情况，手机开发一般用canvas方法加载：\n\n具体的canvas API 参见：http://javascript.ruanyifeng.com/htmlapi/canvas.html\n\n下面举例说明一个canvas的例子：\n\n```html\n<li><canvas></canvas></li>\n\n//js动态加载图片和li 总共举例17张图片！\n<script>\nvartotal=17; \n\nvarzWin=$(window); \n\nvarrender=function(){\n\n  varpadding=2; \n\n  varwinWidth=zWin.width(); \n\n  varpicWidth=Math.floor((winWidth-padding*3)/4); \n\n  vartmpl ='';\n\n  for(vari=1;i<=totla;i++){ \n\n     varp=padding; \n\n     varimgSrc='img/'+i+'.jpg';\n\n     if(i%4==1){\n\n        p=0;\n\n     }\n\n  tmpl +='<li style=\"width:'+picWidth+'px;height:'+picWidth+'px;padding-left:'+p+'px;padding-top:'+padding+'px;\"><canvas id=\"cvs_'+i+'\"></canvas></li>';\n\n  varimageObj = newImage(); \n\n  imageObj.index = i; \n\n  imageObj.onload = function(){\n\n    varcvs =$('#cvs_'+this.index)[0].getContext('2d');\n\n    cvs.width = this.width;\n\n    cvs.height=this.height;\n\n    cvs.drawImage(this,0,0);\n\n  }\n\n  imageObj.src=imgSrc;\n\n  }\n\n}\n\nrender();\n</script>\n```\n\n\n\n#####3、假如手机网站不用兼容IE浏览器，一般我们会使用zeptojs\n\nzeptojs内置Touch events方法，具体可以看http://zeptojs.com/#Touch events\n\n看了一下zeptio新版的API，已经支持IE10以上浏览器，对zeptojs可以选择使用！\n\n#####4、防止手机中网页放大和缩小。#####\n\n这点是最基本的，最为手机网站开发者来说应该都知道的，就是设置meta中的viewport\n\n还有就是，有些手机网站我们看到如下声明：\n\n代码如下:\n\n`<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.0//EN\" \"http://www.wapforum.org/DTD/xhtml-mobile10.dtd\">`\n\n设置了DTD的方式是XHTML的写法，假如我们页面运用的是html5，可以不用设置DTD,直接声明<!DOCTYPE html>。\n\n使用viewport使页面禁止缩放。 通常把user-scalable设置为0来关闭用户对页面视图缩放的行为。\n\n`<meta name=\"viewport\"content=\"user-scalable=0\"/>`\n\n但是为了更好的兼容，我们会使用完整的viewport设置。\n\n[复制代码]()代码如下:\n\n`<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0\" />`\n\n当然，`user-scalable=0`,有的人也写成`user-scalable=no`，都可以的。\n\n#####5、apple-mobile-web-app-capable#####\n\napple-mobile-web-app-capable是设置Web应用是否以全屏模式运行。\n\n语法：\n\n`<meta name=\"apple-mobile-web-app-capable\"content=\"yes\">`\n\n说明：\n\n如果content设置为yes，Web应用会以全屏模式运行，反之，则不会。content的默认值是no，表示正常显示。你可以通过只读属性window.navigator.standalone来确定网页是否以全屏模式显示。\n\n#####6、format-detection#####\n\nformat-detection 启动或禁用自动识别页面中的电话号码。\n\n语法：\n\n`<meta name=\"format-detection\"content=\"telephone=no\">`\n\n说明：\n\n默认情况下，设备会自动识别任何可能是电话号码的字符串。设置telephone=no可以禁用这项功能。\n\n#####7、html5调用安卓或者ios的拨号功能#####\n\nhtml5提供了自动调用拨号的标签，只要在a标签的href中添加tel:就可以了。\n\n如下：\n\n`<a href=\"tel:4008106999,1034\">400-810-6999 转 1034</a>`\n\n拨打手机直接如下\n\n` <a href=\"tel:15677776767\">点击拨打15677776767</a>`\n#####8、html5GPS定位功能#####\n\n具体请看：http://www.w3school.com.cn/html5/html_5_geolocation.asp\n\n#####9、上下拉动滚动条时卡顿、慢#####\n\n`body {-webkit-overflow-scrolling: touch; overflow-scrolling: touch;}`\n\nAndroid3+和iOS5+支持CSS3的新属性为overflow-scrolling\n\n#####10、禁止复制、选中文本#####\n\n```css\nElement {-webkit-user-select:none;\n\n  -moz-user-select:none;\n\n  -khtml-user-select:none;\n\n   user-select:none;\n\n}\n\n```\n\n\n\n解决移动设备可选中页面文本(视产品需要而定)\n\n##### 11、长时间按住页面出现闪退\n\n```css\nelement {\n\n  -webkit-touch-callout:none;\n\n}\n```\n\n\n\n#####12、iphone及ipad下输入框默认内阴影#####\n\n```css\nElement{\n  -webkit-appearance:none;\n}\n```\n\n\n\n#####13、ios和android下触摸元素时出现半透明灰色遮罩#####\n\n```css\nElement {\n  -webkit-tap-highlight-color:rgba(255,255,255,0)\n}\n\n```\n\n\n\n设置alpha值为0就可以去除半透明灰色遮罩，备注：transparent的属性值在android下无效。\n\n后面一篇文章有详细介绍，地址：http://www.jb51.net/post/phone_web_ysk\n\n#####14、active兼容处理 即 伪类 :active 失效#####\n\n方法一：body添加ontouchstart\n\n`<body ontouchstart=\"\">`\n\n方法二：js给 document 绑定 touchstart 或 touchend 事件\n```css\n<style>\n   a {\n     color:#000;\n   }\n   a:active {\n      color:#fff;\n    }\n    </style>\n    <a herf=foo >bar</a>\n <script>\n    document.addEventListener('touchstart',function(){},false);\n</script>\n```\n#####15、动画定义3D启用硬件加速#####\n\n```css\nElement {\n\n  -webkit-transform:translate3d(0,0,0)\n\n  transform: translate3d(0,0,0);\n\n}\n\n```\n\n\n\n注意：3D变形会消耗更多的内存与功耗\n\n#####16、Retina屏的1px边框#####\n\n```css\nElement{\n\n  border-width:thin;\n\n}\n\n```\n\n\n\n#####17、webkit mask 兼容处理#####\n\n某些低端手机不支持css3 mask，可以选择性的降级处理。\n\n比如可以使用js判断来引用不同class：\n\n```javascript\nif('WebkitMask'indocument.documentElement.style){\n\n  alert('支持mask');\n\n}else{\n\n  alert('不支持mask');\n\n}\n\n```\n\n\n\n#####18、旋转屏幕时，字体大小调整的问题#####\n\n```css\nhtml, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6{\n\n  -webkit-text-size-adjust:100%;\n\n}\n\n```\n\n\n\n#####19、transition闪屏#####\n\n设置内嵌的元素在3D 空间如何呈现：保留3D \n`-webkit-transform-style: preserve-3d;`\n设置进行转换的元素的背面在面对用户时是否可见：隐藏 /\n`-webkit-backface-visibility:hidden;`\n\n#####20、圆角bug#####\n\n某些Android手机圆角失效\n\n`background-clip: padding-box;`\n\n#####21、顶部状态栏背景色#####\n\n`meta name=\"apple-mobile-web-app-status-bar-style\"content=\"black\"/>`\n\n说明：\n\n除非你先使用apple-mobile-web-app-capable指定全屏模式，否则这个meta标签不会起任何作用。\n\n如果content设置为default，则状态栏正常显示。如果设置为blank，则状态栏会有一个黑色的背景。如果设置为blank-translucent，则状态栏显示为黑色半透明。如果设置为default或blank，则页面显示在状态栏的下方，即状态栏占据上方部分，页面占据下方部分，二者没有遮挡对方或被遮挡。如果设置为blank-translucent，则页面会充满屏幕，其中页面顶部会被状态栏遮盖住（会覆盖页面20px高度，而iphone4和itouch4的Retina屏幕为40px）。默认值是default。\n\n#####22、设置缓存#####\n\n`<meta http-equiv=\"Cache-Control\"content=\"no-cache\"/>`\n\n手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。\n\n#####23、桌面图标#####\n\n```html\n<link rel=\"apple-touch-icon\"href=\"touch-icon-iphone.png\"/>\n\n<link rel=\"apple-touch-icon\"sizes=\"76x76\"href=\"touch-icon-ipad.png\"/>\n\n<link rel=\"apple-touch-icon\"sizes=\"120x120\"href=\"touch-icon-iphone-retina.png\"/>\n\n<link rel=\"apple-touch-icon\"sizes=\"152x152\"href=\"touch-icon-ipad-retina.png\"/>\n\n```\n\n\n\niOS下针对不同设备定义不同的桌面图标。如果不定义则以当前屏幕截图作为图标。\n\n上面的写法可能大家会觉得会有默认光泽，下面这种设置方法可以去掉光泽效果，还原设计图的效果！\n\n `  <link rel=\"apple-touch-icon-precomposed\"href=\"touch-icon-iphone.png\"/>`\n\n图片尺寸可以设定为5757（px）或者Retina可以定为114114（px），ipad尺寸为72*72（px)\n\n#####24、启动画面#####\n\n`<link rel=\"apple-touch-startup-image\"href=\"start.png\"/>`\n\niOS下页面启动加载时显示的画面图片，避免加载时的白屏。\n\n可以通过madia来指定不同的大小：\n\n```html\n<!--iPhone-->\n\n<link href=\"apple-touch-startup-image-320x460.png\"media=\"(device-width: 320px)\" rel=\"apple-touch-startup-image\"/>\n\n<!-- iPhone Retina -->\n\n<link href=\"apple-touch-startup-image-640x920.png\"media=\"(device-width: 320px) and (-webkit-device-pixel-ratio: 2)\" rel=\"apple-touch-startup-image\"/>\n\n<!-- iPhone 5-->\n\n<link rel=\"apple-touch-startup-image\"media=\"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)\" href=\"apple-touch-startup-image-640x1096.png\">\n\n<!-- iPad portrait-->\n\n<link href=\"apple-touch-startup-image-768x1004.png\"media=\"(device-width: 768px) and (orientation: portrait)\" rel=\"apple-touch-startup-image\"/>\n\n<!-- iPad landscape-->\n\n<link href=\"apple-touch-startup-image-748x1024.png\"media=\"(device-width: 768px) and (orientation: landscape)\" rel=\"apple-touch-startup-image\"/>\n\n<!-- iPad Retina portrait-->\n\n<link href=\"apple-touch-startup-image-1536x2008.png\"media=\"(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)\" rel=\"apple-touch-startup-image\"/>\n\n<!-- iPad Retina landscape-->\n\n<link href=\"apple-touch-startup-image-1496x2048.png\"media=\"(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)\"rel=\"apple-touch-startup-image\"/>\n\n```\n\n\n\n#####25、浏览器私有及其它meta#####\n\n以下属性在项目中没有应用过，可以写一个demo测试以下！\n\nQQ浏览器私有\n\n全屏模式\n\n`<meta name=\"x5-fullscreen\"content=\"true\">`\n\n强制竖屏\n\n`<meta name=\"x5-orientation\"content=\"portrait\">`\n\n强制横屏\n\n`<meta name=\"x5-orientation\"content=\"landscape\">`\n\n应用模式\n\n`meta name=\"x5-page-mode\"content=\"app\">`\n\nUC浏览器私有\n\n全屏模式\n\n`<meta name=\"full-screen\"content=\"yes\">`\n\n强制竖屏\n\n`<meta name=\"screen-orientation\"content=\"portrait\">`\n\n强制横屏\n\n`<meta name=\"screen-orientation\"content=\"landscape\">`\n\n应用模式\n\n`<meta name=\"browsermode\"content=\"application\">`\n\n其它\n\n针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓\n\n`<meta name=\"HandheldFriendly\"content=\"true\">`\n\n微软的老式浏览器\n\n`<meta name=\"MobileOptimized\"content=\"320\">`\n\nwindows phone 点击无高光\n\n`<meta name=\"msapplication-tap-highlight\"content=\"no\">`\n\n#####26、 IOS中input键盘事件keyup、keydown、keypress支持不是很好#####\n\n问题是这样的，用input search做模糊搜索的时候，在键盘里面输入关键词，会通过ajax后台查询，然后返回数据，然后再对返回的数据进行关键词标红。用input监听键盘keyup事件，在安卓手机浏览器中是可以的，但是在ios手机浏览器中变红很慢，用输入法输入之后，并未立刻相应keyup事件，只有在通过删除之后才能相应！\n\n解决办法：\n\n可以用html5的oninput事件去代替keyup\n```javascript\n<input type=\"text\"id=\"testInput\">\n<script type=\"text/javascript\">\n  document.getElementById('testInput').addEventListener('input',function(e){\n    varvalue = e.target.value;\n  });\n</script>\n```\n然后就达到类似keyup的效果！\n\n#####27、h5网站input 设置为type=number的问题#####\n\nh5网页input 的type设置为number一般会产生三个问题，一个问题是maxlength属性不好用了。另外一个是form提交的时候，默认给取整了。三是部分安卓手机出现样式问题。\n\n问题一解决，我目前用的是js。如下\n```javascript\n<input type=\"number\"oninput=\"checkTextLength(this ,10)\">\nfunction checkTextLength(obj, length) {  \n      if(obj.value.length > length)  {     \n        obj.value = obj.value.substr(0, length);  \n      } \n}\n```\n问题二，是因为form提交默认做了表单验证，step默认是1,要设置step属性，假如保留2位小数，写法如下：\n\n`<input type=\"number\" step=\"0.01\"/>`\n\n关于step，我在这里做简单的介绍，input 中type=number，一般会自动生成一个上下箭头，点击上箭头默认增加一个step，点击下箭头默认会减少一个step。number中默认step是1。也就是step=0.01,可以允许输入2位小数，并且点击上下箭头分别增加0.01和减少0.01。\n\n假如step和min一起使用，那么数值必须在min和max之间。\n\n看下面的例子：\n\n`<input type=\"number\"step=\"3.1\"min=\"1\"/>`\n\n输入框可以输入哪些数字？\n\n首先，最小值是1，那么可以输入1.0，第二个是可以输入（1+3.1）那就是4.1,以此类推，每次点击上下箭头都会增加或者减少3.1，输入其他数字无效。这就是step的简单介绍。\n\n问题三，去除input默认样式\n\n```css\ninput[type=number] {\n\n  -moz-appearance:textfield;\n\n}\n\ninput[type=number]::-webkit-inner-spin-button,\n\ninput[type=number]::-webkit-outer-spin-button {\n\n  -webkit-appearance:none;\n\n  margin:0;\n\n}\n\n```\n\n\n\n#####28、ios 设置input 按钮样式会被默认样式覆盖#####\n\n解决方式如下：\n\n```css\ninput,\n\ntextarea {\n\n  border: 0; \n\n  -webkit-appearance: none; \n\n}\n\n```\n\n\n\n设置默认样式为none\n\n#####29、IOS键盘字母输入，默认首字母大写#####\n\n解决方案，设置如下属性\n\n`<input type=\"text\"autocapitalize=\"off\"/>`\n\n#####30、select 下拉选择设置右对齐#####\n\n设置如下：\n\n```css\nselect option {\n\n       direction: rtl;\n\n}\n\n```\n\n\n\n#####31、通过transform进行skew变形，rotate旋转会造成出现锯齿现象#####\n\n可以设置如下：\n\n```css\n-webkit-transform: rotate(-4deg) skew(10deg) translateZ(0);\n\n transform: rotate(-4deg) skew(10deg) translateZ(0);\n\n outline: 1px solid rgba(255,255,255,0)\n\n```\n\n\n\n#####32、移动端点击300ms延迟#####\n\n300ms尚可接受，不过因为300ms产生的问题，我们必须要解决。300ms导致用户体验并不是很好，解决这个问题，我们一般在移动端用tap事件来取代click事件。\n\n推荐两个js，一个是fastclick，一个是tap.js\n\n关于300ms延迟，具体请看：http://thx.github.io/mobile/300ms-click-delay/\n\n#####33、移动端点透问题#####\n\n案例如下：\n```html\n<div id=\"haorooms\">点头事件测试</div>\n<a href=\"www.baidu.net\">www.baidu.com</a>\n```\ndiv是绝对定位的蒙层,并且z-index高于a。而a标签是页面中的一个链接，我们给div绑定tap事件：\n\n```javascript\n$('#haorooms').on('tap',function(){\n\n\t$('#haorooms').hide();\n\n});\n\n```\n\n\n\n我们点击蒙层时 div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。\n\n原因：\n\ntouchstart 早于 touchend 早于click。 亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。\n解决：\n\n（1）尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。\n（2）用fastclick，https://github.com/ftlabs/fastclick\n（3）用preventDefault阻止a标签的click\n（4）延迟一定的时间(300ms+)来处理事件 （不推荐）\n（5）以上一般都能解决，实在不行就换成click事件。\n下面介绍一下touchend事件，如下：\n\n```javascript\n$(\"#haorooms\").on(\"touchend\",function(event) {\n\n   event.preventDefault();\n\n });\n\n```\n\n\n\n#####34、消除 IE10 里面的那个叉号#####\n\n`input:-ms-clear{display:none;}`\n\n#####35、关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等)#####\n\niOS 浏览器横屏时会重置字体大小，设置 text-size-adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text-size-adjust 为 100% 。\n\n```css\n-webkit-text-size-adjust:100%;\n\n-ms-text-size-adjust:100%;\n\ntext-size-adjust:100%;\n\n```\n\n\n\n#####36、关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格#####\n\n可以通过正则去掉\n\n`his.value = this.value.replace(/\\u2006/g,'');`\n\n#####37、移动端 HTML5 audio autoplay 失效问题#####\n\n这个不是 BUG，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。\n\n解决方法思路：先通过用户 touchstart 触碰，触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。\n\n解决代码：\n\n```javascript\ndocument.addEventListener('touchstart',function() {\n\n  document.getElementsByTagName('audio')[0].play();\n\n  document.getElementsByTagName('audio')[0].pause();\n\n});\n```\n\n#####38、移动端 HTML5 input date 不支持 placeholder 问题#####\n\n这个我感觉没有什么好的解决方案，用如下方法\n\n[复制代码]()代码如下:\n\n`<input placeholder=\"Date\" class=\"textbox-n\" type=\"text\" onfocus=\"(this.type='date')\"  id=\"date\">`\n\n有的浏览器可能要点击两遍！\n\n#####39、部分机型存在type为search的input，自带close按钮样式修改方法#####\n\n有些机型的搜索input控件会自带close按钮（一个伪元素），而通常为了兼容所有浏览器，我们会自己实现一个，此时去掉原生close按钮的方法为\n\n```css\n#Search::-webkit-search-cancel-button{\n\n  display:none; \n\n}\n\n```\n\n\n\n如果想使用原生close按钮，又想使其符合设计风格，可以对这个伪元素的样式进行修改。\n\n#####40、唤起select的option展开#####\n\nzepto方式:\n\n`$(sltElement).trrgger(\"mousedown\");`\n\n原生js方式:\n\n```javascript\nfunctionshowDropdown(sltElement) {\n\n  varevent;\n\n  event = document.createEvent('MouseEvents');\n\n  event.initMouseEvent('mousedown',true,true, window);\n\n  sltElement.dispatchEvent(event);\n\n};\n\n```\n\n\n\n文章转载：http://www.jb51.net/article/84973.htm","tags":["移动端"]},{"title":"ES6函数新增的特性","url":"/ES6函数新增的特性/","content":"\n# 函数新增特性\n\n## 带默认参数的函数\n\n> JavaScript函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。\n\n```javascript\nfunction makeRequest(url, timeout, callback) {\n    timeout = timeout || 2000;\n    callback = callback || function() {};\n}\n```\n\n<!--more-->\n\n其实上面的默认值方法有个bug：当timeout是0的时候也会当做假值来处理，从而给赋值默认值2000.\n\n> ES6从语言层面面上增加了 **默认值的** 支持。看下面的代码：\n\n```javascript\n//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。\nfunction makeRequest(url, timeout = 2000, callback = function() {}) {\n\n    // 其余代码\n\n}\n```\n\n## 默认参数对 arguments 对象的影响\t\n\n> 在非严格模式下，arguments总是能反映出命名参数的变化。看下面的代码：\n\n```javascript\n<script type=\"text/javascript\">\n    function foo(a, b) {\n        //非严格模式\n        console.log(arguments[0] === a); //true\n        console.log(arguments[1] === b); //true\n        a = 10;\n        b = 20;\n        console.log(arguments[0] === a); //true\n        console.log(arguments[1] === b); //true\n    }\n    foo(1, 2);\n</script>\n```\n\n> **在ES5的严格模式下**，arguments只反映参数的初始值，而不再反映命名参数的变化！\n\n```Javascript\n<script type=\"text/javascript\">\n\n    function foo(a, b) {\n        //严格模式\n        \"use strict\"\n        console.log(arguments[0] === a); //true\n        console.log(arguments[1] === b); //true\n        a = 10;\n        b = 20;\n        console.log(arguments[0] === a); //false。  修改a的值不会影响到arguments[0]的值\n        console.log(arguments[1] === b); //false\n    }\n    foo(1, 2);\n</script>\n```\n\n> 当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。看下面的代码：\n\n```Javascript\n<script type=\"text/javascript\">\n\n    function foo(a, b = 30) {\n        console.log(arguments[0] === a); //true\n        console.log(arguments[1] === b); //true\n        a = 10;\n        b = 20;\n        console.log(arguments[0]  === a); //false。  由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。\n        console.log(arguments[1] === b); //false。  b使用了默认值，所以表现的和严格模式一样。\n    }\n    foo(1, 2);\n</script>\n```\n\n> 注意：如果这样调用foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给arguments参数。\n\n## 默认参数表达式 (**Default Parameter Expressions**)\n\n> 参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码\n\n```javascript\n<script type=\"text/javascript\">\n    function getValue() {\n        return 5;\n    }\n\n    function add(first, second = getValue()) { //表示使用getValue这个函数的返回值作为second的默认值。\n        return first + second;\n    }\n\n    console.log(add(1, 1));     // 2.  调用add函数的时候，传入了第二个参数，则以传入的参数为准。\n    console.log(add(1));        // 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。\n</script>\n```\n\n> 有一点需要要注意：getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。\n\n```javascript\n<script type=\"text/javascript\">\n    let value = 5;\n    function getValue() {\n        return value++;\n    }\n\n    function add(first, second = getValue()) {  //\n        return first + second;\n    }\n\n    console.log(add(1, 1));     // 2\n    console.log(add(1));        // 6。 \n    console.log(add(1));        // 7\n    console.log(add(1));        // 8\n</script>\n```\n\n> 由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。\n\n```javascript\nfunction add(first, second = first) {  // 使用第一个参数作为第二个参数的默认值\n        return first + second;\n }\n\n```\n\n> 注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的let和const的暂存性死区一个意思。\n\n```javascript\nfunction add(first = second, second)) {  // 这种写法是错误的\n\n        return first + second;\n}\n```\n\n## 未命名参数问题\n\n> Javascript并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是罗显繁琐。\n\n```javascript\n<script type=\"text/javascript\">\n    function foo(a) {\n        console.log(a);\n        console.log(arguments[1])  //取得传入的多余的参数。\n    }\n    foo(2, 3);\n</script>\n```\n\n> ES6，提供了一种更加优雅处理未命名参数的问题：**剩余参数**( **Rest Parameters** )\n>\n> 语法：function a(a, … b){ }   \n>\n> 剩余参数使用三个点( … )和变量名来表示。\n\n```javascript\n<script type=\"text/javascript\">\n    function foo(a, ...b) {\n        console.log(a);\n        console.log(b instanceof Array);  //true  .多余的参数都被放入了b中。b其实就是一个数组。\n    }\n    foo(2, 3, 4, 6);\n</script>\n```\n\n> 注意：\n\n1. 函数最多只能有一个剩余参数b。而且这个剩余参数必须位于参数列表的最后位置。\n2. 虽然有了剩余参数，但是arguments仍然存在，但是arguments完全无视了剩余参数的存在。\n3. 剩余参数是在函数声明的时候出现的。\n\n\n\n## 函数中的扩展运算符\n\n> 例如:Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用applay方法。\n>\n> 看下面的代码：\n\n```javascript\n<script type=\"text/javascript\">\n    let values = [25, 50, 75, 100]\t\n    console.log(Math.max.apply(Math, values));  // 100\n</script>\n```\n\n> 上面这种方法虽然可行，但是总是不是那么直观。\n>\n> 使用ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。\n\n```Javascript\n<script type=\"text/javascript\">\n    let values = [25, 50, 75, 100]\n    console.log(Math.max(...values));  //使用扩展运算符。相当于拆解了数组了。\n\tconsole.log(Math.max(...values, 200));  //也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。\n</script>\n```\n\n> **注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。**\n>\n> 1. ****剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面\n> 2. 扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。\n\n# 全新的函数：箭头函数（=>）\n\n> ECMAScript 6 最有意思的部分之一就是箭头函数。正如其名，箭头函数由 “箭头”（=>）这种新的语法来定义。\n>\n> 其实在别的语言中早就有了这种语法结构，不过他们叫拉姆达表达式。\n\n## 箭头函数语法\n\n> 基本语法如下：\n\n```javascript\n(形参列表)=>{\n  //函数体\n}\n```\n\n---\n\n> 箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。\n\n- 示例1：\n\n```javascript\n<script type=\"text/javascript\">\n    var sum = (num1, num2) =>{\n        return num1 + num2;\n    }\n    console.log(sum(3, 4));\n    //前面的箭头函数等同于下面的传统函数\n    var add = function (num1, num2) {\n        return num1 + num2;\n    }\n    console.log(add(2, 4))\n</script>\n```\n\n---\n\n> 如果函数体内只有一行代码，则包裹函数体的 **大括号** ({ })完全可以省略。如果有return，return关键字也可以省略。\n>\n> 如果函数体内有多条语句，则 {} 不能省略。\n\n- 示例2：\n\n```javascript\n<script type=\"text/javascript\">\n    var sum = (num1, num2) => num1 + num2;\n    console.log(sum(5, 4));\n    //前面的箭头函数等同于下面的传统函数\n    var add = function (num1, num2) {\n        return num1 + num2;\n    }\n    console.log(add(2, 4));\n\n\t//如果这一行代码是没有返回值的，则方法的返回自也是undefined\n\tvar foo = (num1, num2) => console.log(\"aaa\");\n\tconsole.log(foo(3,4));  //这个地方的返回值就是undefined\n</script>\n```\n\n---\n\n> 如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。**当然如果不传入参数也不可以省略**\n\n- 示例3：\n\n```javascript\n<script type=\"text/javascript\">\n    var foo = a=> a+3; //因为只有一个参数，所以()可以省略\n    console.log(foo(4)); // 7\n</script>\n```\n\n---\n\n> 如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个**小括号 ()**\n\n- 示例4：\n\n```Javascript\n<script type=\"text/javascript\">\n    var foo = ()=>({name:\"lisi\", age:30});\n    console.log(foo());\n\t//等同于下面的；\n\tvar foo1 = ()=>{\n      \treturn {\n          \tname:\"lisi\",\n          \tage : 30\n      \t};\n\t}\n</script>\n```\n\n## 使用箭头函数实现函数自执行\n\n```Javascript\n<script type=\"text/javascript\">\n    var person = (name => {\n            return {\n                name: name,\n                age: 30\n            }\n        }\n    )(\"zs\");\n    console.log(person);\n</script>\n```\n\n## 箭头函数中无this绑定(No this Binding)\n\n> 在ES5之前this的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为this的绑定和定义位置无关，只和调用方式有关。\n>\n> **在箭头函数中则没有这样的问题，在箭头函数中，this和定义时的作用域相关，不用考虑调用方式**\n>\n> 箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。**如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。**\n\n```Javascript\n<script type=\"text/javascript\">\n    var PageHandler = {\n        id: \"123456\",\n        init: function () {\n            document.addEventListener(\"click\",\n                event => this.doSomething(event.type), false); // 在此处this的和init函数内的this相同。\n        },\n\n        doSomething: function (type) {\n            console.log(\"Handling \" + type + \" for \" + this.id);\n        }\n    };\n    PageHandler.init();\n</script>\n```\n\n看下面的一段代码：\n\n```javascript\n<script type=\"text/javascript\">\n\n    var p = {\n        foo:()=>console.log(this)   //此处this为window\n    }\n    p.foo();  //输出为 window对象。   并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。\n//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。\n</script>\n```\n\n> 说明：\n\n1. 箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用new 的方式来使用箭头函数。\n2. 由于箭头函数中的this与函数的作用域相关，所以不能使用call、apply、bind来重新绑定this。但是虽然this不能重新绑定，但是还是可以使用call和apply方法去执行箭头函数的。\n\n\n\n## 无arguments绑定\n\n> 虽然箭头函数没有自己的arguments对象，但是在箭头函数内部还是可以使用它外部函数的arguments对象的。\n\n```javascript\n<script type=\"text/javascript\">\n    function foo() {\n        //这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。\n        return ()=>arguments[0]; //箭头函数的返回值是foo函数的第一个参数\n    }\n    var arrow = foo(4, 5);\n    console.log(arrow()); // 4\n</script>\n```\n","tags":["JavaScript"]},{"title":"ES6块级作用域","url":"/ES6块级作用域/","content":"\n## 块级作用域绑定\n\n> 在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。\n\n块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建：\n\n- 函数内部\n- 在代码块（即 {  }）内部\n\n块级作用域是很多类C语言的工作机制，ECMAScript 6 引入块级声明的目的是增强 JavaScript 的灵活性，同时又能与其它编程语言保持一致。\n\n<!--more-->\n\n## let声明\n\n> 使用let声明变量的语法和使用var声明的语法是一样的。**但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别**。\n\n```javascript\n<script type=\"text/javascript\">\n    let a = 10;\n    if(a > 5){\n        console.log(b); //用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错）\n        let b = 20;\n        console.log(b);\n    }\n    console.log(b); //由于b是在if块中使用let声明的，所以此处无法访问到。（报错）\n</script>\n```\n\n> 注意：\n\n1. 用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问\n2. 用let声明的变量也没有声明提前这一特性。\n3. 在同一个块中，let声明的变量也不能重复声明。\n4. 在声明变量的时候尽量使用let，慢慢的抛弃var\n\n\n\n## const声明(Constant Declarations)\n\n> 在  ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const声明的常量和let变量一样也是具有块级作用域的特性。\n\n```javascript\n<script type=\"text/javascript\">\n    var a = 20;\n    if (true) {\n        const b = 20;\n        b = 30;  //错误! 常量不能重新赋值\n        const c; //错误！ 常量声明的同时必须赋值。\n    }\n</script>\n```\n\n> 注意：\n\n1. const的特性除了声明的是常量为，其他与let一样。\n2. 在let和const声明前的这段区域称之为暂存性死区（**The Temporal Dead Zone** —TDZ)。\n3. 使用let和const声明的变量和常量不再是window的属性。  也就是说通过window.a是无法访问到的。\n\n\n\n## 循环中的块级绑定\n\n> 使用var声明的循环变量在循环结束后仍然可以访问到。   使用let声明的循环变量，在循环结束之后会立即销毁。\n\n```JavaScript\n<script type=\"text/javascript\">\n    for(let i = 0; i < 3; i++){ // 循环结束之后会立即销毁 i\n        console.log(i);\n    }\n    console.log(i);  //此处无法访问到 i 。\n</script>\n```\n\n## 循环中的函数\n\n> 看下面的代码，是输出10个10，而不是0，1，2，...\n\n```javascript\n<script type=\"text/javascript\">\n    var funcs = [];\n    for (var i = 0; i < 10; i++) {\n        funcs.push(function () {\n            console.log(i);\n        });\n    }\n    funcs.forEach(function (func) {\n        func();     // 输出 \"10\" 共10次\n    });\n</script>\n```\n\n> 解决办法需要使用函数的自执行特性。\n\n```javascript\nvar funcs = [];\nfor (var i = 0; i < 10; i++) {\n    funcs.push((function(value) {\n        return function() {\n            console.log(value);\n        }\n    }(i)));\n}\nfuncs.forEach(function(func) {\n    func();     // 输出 0，1，2 ... 9\n});\n```\n\n**如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for ... of循环中也适用**\n\n```Javascript\n<script type=\"text/javascript\">\n    var funcs = [];\n    for (let i = 0; i < 10; i++) {\n        funcs.push(function () {\n            console.log(i);\n        });\n    }\n    funcs.forEach(function (func) {\n        func();     // 输出 0，1，2 ... 9\n    })\n</script>\n```\n\n> 说明：\n\n1. let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。","tags":["JavaScript"]},{"title":"Flex布局","url":"/Flex布局/","content":"\n## Flex布局是什么？\n\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n\n任何一个容器都可以指定为 Flex 布局。\n\n<!--more-->\n\n### 定义容器的display属性\n\n```css\n.box{\n  \tdisplay: -webkit-flex;\n  \tdispaly: flex;\n}\n/*行内样式*/\n.box{\n  \tdisplay: -webkit-inline-flex;\n  \tdisplay: inline-flex;\n}\n```\n\n### 容器样式\n\n**主轴方向（flex-direction）**\n\n| 属性值            | 属性的含义   |\n| -------------- | ------- |\n| row            | 左到右（默认） |\n| row-reverse    | 右到左     |\n| column         | 上到下     |\n| column-reverse | 下到上     |\n\n**换行（flex-wrap）**\n\n| 属性值          | 属性的含义     |\n| ------------ | --------- |\n| nowrap       | 不换行（默认）   |\n| wrap         | 换行        |\n| wrap-reverse | 换行并第一行在下方 |\n\n**主轴方向和换行简写**\n\n```css\nflew-flow:<flex-direction>||<flex-wrap>\n```\n\n**主轴对齐方式（justify-content）**\n\n| 属性值           | 属性的含义   |\n| ------------- | ------- |\n| flex-start    | 左对齐（默认） |\n| flex-end      | 右对齐     |\n| center        | 居中对齐    |\n| space-between | 两端对齐    |\n| space-around  | 平均分布    |\n\n**交叉轴对齐方式（align-items）**\n\n| 属性值        | 属性的含义                            |\n| ---------- | -------------------------------- |\n| flex-start | 顶部对齐                             |\n| flex-end   | 底部对齐                             |\n| center     | 居中对齐                             |\n| baseline   | 文本基线对齐                           |\n| stretch    | 如果项目未设置高度或设为auto，将占满整个容器的高度。（默认） |\n\n### 子元素属性\n\n**排序（order：<number>）**：排序，数值越小，越排前，默认为0\n\n**放大（flex-grow: <number>）**：放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）\n\n**缩小（flex-shrink:<number>）**：缩小：如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。\n\n**固定大小（flex-basis:<length> | auto）**:固定大小：默认为0，可以设置px值，也可以设置百分比大小\n\n**flex:none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]**：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。\n\n**单独对齐方式（align-self）**\n\n\n\n| 属性值        | 含义      |\n| ---------- | ------- |\n| auto       | 自动（默认）  |\n| flex-start | 顶部对齐    |\n| flex-end   | 底部对齐    |\n| center     | 居中对齐    |\n| baseline   | 文本基线对齐  |\n| stretch    | 上下对齐并铺满 |","tags":["css3"]}]