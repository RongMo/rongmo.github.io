[{"title":"ES6块级作用域","url":"/ES6块级作用域/","content":"\n## 块级作用域绑定\n\n> 在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。\n\n块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建：\n\n- 函数内部\n- 在代码块（即 {  }）内部\n\n块级作用域是很多类C语言的工作机制，ECMAScript 6 引入块级声明的目的是增强 JavaScript 的灵活性，同时又能与其它编程语言保持一致。\n\n## let声明\n\n> 使用let声明变量的语法和使用var声明的语法是一样的。**但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别**。\n\n```javascript\n<script type=\"text/javascript\">\n    let a = 10;\n    if(a > 5){\n        console.log(b); //用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错）\n        let b = 20;\n        console.log(b);\n    }\n    console.log(b); //由于b是在if块中使用let声明的，所以此处无法访问到。（报错）\n</script>\n```\n\n> 注意：\n\n1. 用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问\n2. 用let声明的变量也没有声明提前这一特性。\n3. 在同一个块中，let声明的变量也不能重复声明。\n4. 在声明变量的时候尽量使用let，慢慢的抛弃var\n\n\n\n## const声明(Constant Declarations)\n\n> 在  ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const声明的常量和let变量一样也是具有块级作用域的特性。\n\n```javascript\n<script type=\"text/javascript\">\n    var a = 20;\n    if (true) {\n        const b = 20;\n        b = 30;  //错误! 常量不能重新赋值\n        const c; //错误！ 常量声明的同时必须赋值。\n    }\n</script>\n```\n\n> 注意：\n\n1. const的特性除了声明的是常量为，其他与let一样。\n2. 在let和const声明前的这段区域称之为暂存性死区（**The Temporal Dead Zone** —TDZ)。\n3. 使用let和const声明的变量和常量不再是window的属性。  也就是说通过window.a是无法访问到的。\n\n\n\n## 循环中的块级绑定\n\n> 使用var声明的循环变量在循环结束后仍然可以访问到。   使用let声明的循环变量，在循环结束之后会立即销毁。\n\n```JavaScript\n<script type=\"text/javascript\">\n    for(let i = 0; i < 3; i++){ // 循环结束之后会立即销毁 i\n        console.log(i);\n    }\n    console.log(i);  //此处无法访问到 i 。\n</script>\n```\n\n## 循环中的函数\n\n> 看下面的代码，是输出10个10，而不是0，1，2，...\n\n```javascript\n<script type=\"text/javascript\">\n    var funcs = [];\n    for (var i = 0; i < 10; i++) {\n        funcs.push(function () {\n            console.log(i);\n        });\n    }\n    funcs.forEach(function (func) {\n        func();     // 输出 \"10\" 共10次\n    });\n</script>\n```\n\n> 解决办法需要使用函数的自执行特性。\n\n```javascript\nvar funcs = [];\nfor (var i = 0; i < 10; i++) {\n    funcs.push((function(value) {\n        return function() {\n            console.log(value);\n        }\n    }(i)));\n}\nfuncs.forEach(function(func) {\n    func();     // 输出 0，1，2 ... 9\n});\n```\n\n**如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for ... of循环中也适用**\n\n```Javascript\n<script type=\"text/javascript\">\n    var funcs = [];\n    for (let i = 0; i < 10; i++) {\n        funcs.push(function () {\n            console.log(i);\n        });\n    }\n    funcs.forEach(function (func) {\n        func();     // 输出 0，1，2 ... 9\n    })\n</script>\n```\n\n> 说明：\n\n1. let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。","tags":["JavaScript,ES6"]},{"title":"Flex布局","url":"/Flex布局/","content":"\n### 定义容器的display属性\n\n```css\n.box{\n  \tdisplay: -webkit-flex;\n  \tdispaly: flex;\n}\n/*行内样式*/\n.box{\n  \tdisplay: -webkit-inline-flex;\n  \tdisplay: inline-flex;\n}\n```\n\n### 容器样式\n\n**主轴方向（flex-direction）**\n\n| 属性值            | 属性的含义   |\n| -------------- | ------- |\n| row            | 左到右（默认） |\n| row-reverse    | 右到左     |\n| column         | 上到下     |\n| column-reverse | 下到上     |\n\n**换行（flex-wrap）**\n\n| 属性值          | 属性的含义     |\n| ------------ | --------- |\n| nowrap       | 不换行（默认）   |\n| wrap         | 换行        |\n| wrap-reverse | 换行并第一行在下方 |\n\n**主轴方向和换行简写**\n\n```css\nflew-flow:<flex-direction>||<flex-wrap>\n```\n\n**主轴对齐方式（justify-content）**\n\n| 属性值           | 属性的含义   |\n| ------------- | ------- |\n| flex-start    | 左对齐（默认） |\n| flex-end      | 右对齐     |\n| center        | 居中对齐    |\n| space-between | 两端对齐    |\n| space-around  | 平均分布    |\n\n**交叉轴对齐方式（align-items）**\n\n| 属性值        | 属性的含义                            |\n| ---------- | -------------------------------- |\n| flex-start | 顶部对齐                             |\n| flex-end   | 底部对齐                             |\n| center     | 居中对齐                             |\n| baseline   | 文本基线对齐                           |\n| stretch    | 如果项目未设置高度或设为auto，将占满整个容器的高度。（默认） |\n\n### 子元素属性\n\n**排序（order：<number>）**：排序，数值越小，越排前，默认为0\n\n**放大（flex-grow: <number>）**：放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）\n\n**缩小（flex-shrink:<number>）**：缩小：如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。\n\n**固定大小（flex-basis:<length> | auto）**:固定大小：默认为0，可以设置px值，也可以设置百分比大小\n\n**flex:none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]**：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。\n\n**单独对齐方式（align-self）**\n\n\n\n| 属性值        | 含义      |\n| ---------- | ------- |\n| auto       | 自动（默认）  |\n| flex-start | 顶部对齐    |\n| flex-end   | 底部对齐    |\n| center     | 居中对齐    |\n| baseline   | 文本基线对齐  |\n| stretch    | 上下对齐并铺满 |","tags":["css3"]}]