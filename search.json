[{"title":"ES6函数新增的特性","url":"/ES6函数新增的特性/","content":"\n# 函数新增特性\n\n## 带默认参数的函数\n\n> JavaScript函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。\n\n```javascript\nfunction makeRequest(url, timeout, callback) {\n    timeout = timeout || 2000;\n    callback = callback || function() {};\n}\n```\n\n其实上面的默认值方法有个bug：当timeout是0的时候也会当做假值来处理，从而给赋值默认值2000.\n\n> ES6从语言层面面上增加了 **默认值的** 支持。看下面的代码：\n\n```javascript\n//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。\nfunction makeRequest(url, timeout = 2000, callback = function() {}) {\n\n    // 其余代码\n\n}\n```\n\n<!--more-->\n\n## 默认参数对 arguments 对象的影响\t\n\n> 在非严格模式下，arguments总是能反映出命名参数的变化。看下面的代码：\n\n```javascript\n<script type=\"text/javascript\">\n    function foo(a, b) {\n        //非严格模式\n        console.log(arguments[0] === a); //true\n        console.log(arguments[1] === b); //true\n        a = 10;\n        b = 20;\n        console.log(arguments[0] === a); //true\n        console.log(arguments[1] === b); //true\n    }\n    foo(1, 2);\n</script>\n```\n\n> **在ES5的严格模式下**，arguments只反映参数的初始值，而不再反映命名参数的变化！\n\n```Javascript\n<script type=\"text/javascript\">\n\n    function foo(a, b) {\n        //严格模式\n        \"use strict\"\n        console.log(arguments[0] === a); //true\n        console.log(arguments[1] === b); //true\n        a = 10;\n        b = 20;\n        console.log(arguments[0] === a); //false。  修改a的值不会影响到arguments[0]的值\n        console.log(arguments[1] === b); //false\n    }\n    foo(1, 2);\n</script>\n```\n\n> 当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。看下面的代码：\n\n```Javascript\n<script type=\"text/javascript\">\n\n    function foo(a, b = 30) {\n        console.log(arguments[0] === a); //true\n        console.log(arguments[1] === b); //true\n        a = 10;\n        b = 20;\n        console.log(arguments[0]  === a); //false。  由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。\n        console.log(arguments[1] === b); //false。  b使用了默认值，所以表现的和严格模式一样。\n    }\n    foo(1, 2);\n</script>\n```\n\n> 注意：如果这样调用foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给arguments参数。\n\n## 默认参数表达式 (**Default Parameter Expressions**)\n\n> 参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码\n\n```javascript\n<script type=\"text/javascript\">\n    function getValue() {\n        return 5;\n    }\n\n    function add(first, second = getValue()) { //表示使用getValue这个函数的返回值作为second的默认值。\n        return first + second;\n    }\n\n    console.log(add(1, 1));     // 2.  调用add函数的时候，传入了第二个参数，则以传入的参数为准。\n    console.log(add(1));        // 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。\n</script>\n```\n\n> 有一点需要要注意：getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。\n\n```javascript\n<script type=\"text/javascript\">\n    let value = 5;\n    function getValue() {\n        return value++;\n    }\n\n    function add(first, second = getValue()) {  //\n        return first + second;\n    }\n\n    console.log(add(1, 1));     // 2\n    console.log(add(1));        // 6。 \n    console.log(add(1));        // 7\n    console.log(add(1));        // 8\n</script>\n```\n\n> 由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。\n\n```javascript\nfunction add(first, second = first) {  // 使用第一个参数作为第二个参数的默认值\n        return first + second;\n }\n\n```\n\n> 注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的let和const的暂存性死区一个意思。\n\n```javascript\nfunction add(first = second, second)) {  // 这种写法是错误的\n\n        return first + second;\n}\n```\n\n## 未命名参数问题\n\n> Javascript并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是罗显繁琐。\n\n```javascript\n<script type=\"text/javascript\">\n    function foo(a) {\n        console.log(a);\n        console.log(arguments[1])  //取得传入的多余的参数。\n    }\n    foo(2, 3);\n</script>\n```\n\n> ES6，提供了一种更加优雅处理未命名参数的问题：**剩余参数**( **Rest Parameters** )\n>\n> 语法：function a(a, … b){ }   \n>\n> 剩余参数使用三个点( … )和变量名来表示。\n\n```javascript\n<script type=\"text/javascript\">\n    function foo(a, ...b) {\n        console.log(a);\n        console.log(b instanceof Array);  //true  .多余的参数都被放入了b中。b其实就是一个数组。\n    }\n    foo(2, 3, 4, 6);\n</script>\n```\n\n> 注意：\n\n1. 函数最多只能有一个剩余参数b。而且这个剩余参数必须位于参数列表的最后位置。\n2. 虽然有了剩余参数，但是arguments仍然存在，但是arguments完全无视了剩余参数的存在。\n3. 剩余参数是在函数声明的时候出现的。\n\n\n\n## 函数中的扩展运算符\n\n> 例如:Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用applay方法。\n>\n> 看下面的代码：\n\n```javascript\n<script type=\"text/javascript\">\n    let values = [25, 50, 75, 100]\t\n    console.log(Math.max.apply(Math, values));  // 100\n</script>\n```\n\n> 上面这种方法虽然可行，但是总是不是那么直观。\n>\n> 使用ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。\n\n```Javascript\n<script type=\"text/javascript\">\n    let values = [25, 50, 75, 100]\n    console.log(Math.max(...values));  //使用扩展运算符。相当于拆解了数组了。\n\tconsole.log(Math.max(...values, 200));  //也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。\n</script>\n```\n\n> **注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。**\n>\n> 1. ****剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面\n> 2. 扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。\n\n# 全新的函数：箭头函数（=>）\n\n> ECMAScript 6 最有意思的部分之一就是箭头函数。正如其名，箭头函数由 “箭头”（=>）这种新的语法来定义。\n>\n> 其实在别的语言中早就有了这种语法结构，不过他们叫拉姆达表达式。\n\n## 箭头函数语法\n\n> 基本语法如下：\n\n```javascript\n(形参列表)=>{\n  //函数体\n}\n```\n\n---\n\n> 箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。\n\n- 示例1：\n\n```javascript\n<script type=\"text/javascript\">\n    var sum = (num1, num2) =>{\n        return num1 + num2;\n    }\n    console.log(sum(3, 4));\n    //前面的箭头函数等同于下面的传统函数\n    var add = function (num1, num2) {\n        return num1 + num2;\n    }\n    console.log(add(2, 4))\n</script>\n```\n\n---\n\n> 如果函数体内只有一行代码，则包裹函数体的 **大括号** ({ })完全可以省略。如果有return，return关键字也可以省略。\n>\n> 如果函数体内有多条语句，则 {} 不能省略。\n\n- 示例2：\n\n```javascript\n<script type=\"text/javascript\">\n    var sum = (num1, num2) => num1 + num2;\n    console.log(sum(5, 4));\n    //前面的箭头函数等同于下面的传统函数\n    var add = function (num1, num2) {\n        return num1 + num2;\n    }\n    console.log(add(2, 4));\n\n\t//如果这一行代码是没有返回值的，则方法的返回自也是undefined\n\tvar foo = (num1, num2) => console.log(\"aaa\");\n\tconsole.log(foo(3,4));  //这个地方的返回值就是undefined\n</script>\n```\n\n---\n\n> 如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。**当然如果不传入参数也不可以省略**\n\n- 示例3：\n\n```javascript\n<script type=\"text/javascript\">\n    var foo = a=> a+3; //因为只有一个参数，所以()可以省略\n    console.log(foo(4)); // 7\n</script>\n```\n\n---\n\n> 如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个**小括号 ()**\n\n- 示例4：\n\n```Javascript\n<script type=\"text/javascript\">\n    var foo = ()=>({name:\"lisi\", age:30});\n    console.log(foo());\n\t//等同于下面的；\n\tvar foo1 = ()=>{\n      \treturn {\n          \tname:\"lisi\",\n          \tage : 30\n      \t};\n\t}\n</script>\n```\n\n## 使用箭头函数实现函数自执行\n\n```Javascript\n<script type=\"text/javascript\">\n    var person = (name => {\n            return {\n                name: name,\n                age: 30\n            }\n        }\n    )(\"zs\");\n    console.log(person);\n</script>\n```\n\n## 箭头函数中无this绑定(No this Binding)\n\n> 在ES5之前this的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为this的绑定和定义位置无关，只和调用方式有关。\n>\n> **在箭头函数中则没有这样的问题，在箭头函数中，this和定义时的作用域相关，不用考虑调用方式**\n>\n> 箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。**如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。**\n\n```Javascript\n<script type=\"text/javascript\">\n    var PageHandler = {\n        id: \"123456\",\n        init: function () {\n            document.addEventListener(\"click\",\n                event => this.doSomething(event.type), false); // 在此处this的和init函数内的this相同。\n        },\n\n        doSomething: function (type) {\n            console.log(\"Handling \" + type + \" for \" + this.id);\n        }\n    };\n    PageHandler.init();\n</script>\n```\n\n看下面的一段代码：\n\n```javascript\n<script type=\"text/javascript\">\n\n    var p = {\n        foo:()=>console.log(this)   //此处this为window\n    }\n    p.foo();  //输出为 window对象。   并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。\n//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。\n</script>\n```\n\n> 说明：\n\n1. 箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用new 的方式来使用箭头函数。\n2. 由于箭头函数中的this与函数的作用域相关，所以不能使用call、apply、bind来重新绑定this。但是虽然this不能重新绑定，但是还是可以使用call和apply方法去执行箭头函数的。\n\n\n\n## 无arguments绑定\n\n> 虽然箭头函数没有自己的arguments对象，但是在箭头函数内部还是可以使用它外部函数的arguments对象的。\n\n```javascript\n<script type=\"text/javascript\">\n    function foo() {\n        //这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。\n        return ()=>arguments[0]; //箭头函数的返回值是foo函数的第一个参数\n    }\n    var arrow = foo(4, 5);\n    console.log(arrow()); // 4\n</script>\n```\n","tags":["ES6 JavaScript"]},{"title":"ES6块级作用域","url":"/ES6块级作用域/","content":"\n## 块级作用域绑定\n\n> 在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。\n\n块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建：\n\n- 函数内部\n- 在代码块（即 {  }）内部\n\n块级作用域是很多类C语言的工作机制，ECMAScript 6 引入块级声明的目的是增强 JavaScript 的灵活性，同时又能与其它编程语言保持一致。\n\n<!--more-->\n\n## let声明\n\n> 使用let声明变量的语法和使用var声明的语法是一样的。**但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别**。\n\n```javascript\n<script type=\"text/javascript\">\n    let a = 10;\n    if(a > 5){\n        console.log(b); //用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错）\n        let b = 20;\n        console.log(b);\n    }\n    console.log(b); //由于b是在if块中使用let声明的，所以此处无法访问到。（报错）\n</script>\n```\n\n> 注意：\n\n1. 用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问\n2. 用let声明的变量也没有声明提前这一特性。\n3. 在同一个块中，let声明的变量也不能重复声明。\n4. 在声明变量的时候尽量使用let，慢慢的抛弃var\n\n\n\n## const声明(Constant Declarations)\n\n> 在  ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const声明的常量和let变量一样也是具有块级作用域的特性。\n\n```javascript\n<script type=\"text/javascript\">\n    var a = 20;\n    if (true) {\n        const b = 20;\n        b = 30;  //错误! 常量不能重新赋值\n        const c; //错误！ 常量声明的同时必须赋值。\n    }\n</script>\n```\n\n> 注意：\n\n1. const的特性除了声明的是常量为，其他与let一样。\n2. 在let和const声明前的这段区域称之为暂存性死区（**The Temporal Dead Zone** —TDZ)。\n3. 使用let和const声明的变量和常量不再是window的属性。  也就是说通过window.a是无法访问到的。\n\n\n\n## 循环中的块级绑定\n\n> 使用var声明的循环变量在循环结束后仍然可以访问到。   使用let声明的循环变量，在循环结束之后会立即销毁。\n\n```JavaScript\n<script type=\"text/javascript\">\n    for(let i = 0; i < 3; i++){ // 循环结束之后会立即销毁 i\n        console.log(i);\n    }\n    console.log(i);  //此处无法访问到 i 。\n</script>\n```\n\n## 循环中的函数\n\n> 看下面的代码，是输出10个10，而不是0，1，2，...\n\n```javascript\n<script type=\"text/javascript\">\n    var funcs = [];\n    for (var i = 0; i < 10; i++) {\n        funcs.push(function () {\n            console.log(i);\n        });\n    }\n    funcs.forEach(function (func) {\n        func();     // 输出 \"10\" 共10次\n    });\n</script>\n```\n\n> 解决办法需要使用函数的自执行特性。\n\n```javascript\nvar funcs = [];\nfor (var i = 0; i < 10; i++) {\n    funcs.push((function(value) {\n        return function() {\n            console.log(value);\n        }\n    }(i)));\n}\nfuncs.forEach(function(func) {\n    func();     // 输出 0，1，2 ... 9\n});\n```\n\n**如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for ... of循环中也适用**\n\n```Javascript\n<script type=\"text/javascript\">\n    var funcs = [];\n    for (let i = 0; i < 10; i++) {\n        funcs.push(function () {\n            console.log(i);\n        });\n    }\n    funcs.forEach(function (func) {\n        func();     // 输出 0，1，2 ... 9\n    })\n</script>\n```\n\n> 说明：\n\n1. let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。","tags":["JavaScript,ES6"]},{"title":"Flex布局","url":"/Flex布局/","content":"\n\n\n\n\n## Flex布局是什么？\n\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n\n任何一个容器都可以指定为 Flex 布局。\n\n<!--more-->\n\n### 定义容器的display属性\n\n```css\n.box{\n  \tdisplay: -webkit-flex;\n  \tdispaly: flex;\n}\n/*行内样式*/\n.box{\n  \tdisplay: -webkit-inline-flex;\n  \tdisplay: inline-flex;\n}\n```\n\n### 容器样式\n\n**主轴方向（flex-direction）**\n\n| 属性值            | 属性的含义   |\n| -------------- | ------- |\n| row            | 左到右（默认） |\n| row-reverse    | 右到左     |\n| column         | 上到下     |\n| column-reverse | 下到上     |\n\n**换行（flex-wrap）**\n\n| 属性值          | 属性的含义     |\n| ------------ | --------- |\n| nowrap       | 不换行（默认）   |\n| wrap         | 换行        |\n| wrap-reverse | 换行并第一行在下方 |\n\n**主轴方向和换行简写**\n\n```css\nflew-flow:<flex-direction>||<flex-wrap>\n```\n\n**主轴对齐方式（justify-content）**\n\n| 属性值           | 属性的含义   |\n| ------------- | ------- |\n| flex-start    | 左对齐（默认） |\n| flex-end      | 右对齐     |\n| center        | 居中对齐    |\n| space-between | 两端对齐    |\n| space-around  | 平均分布    |\n\n**交叉轴对齐方式（align-items）**\n\n| 属性值        | 属性的含义                            |\n| ---------- | -------------------------------- |\n| flex-start | 顶部对齐                             |\n| flex-end   | 底部对齐                             |\n| center     | 居中对齐                             |\n| baseline   | 文本基线对齐                           |\n| stretch    | 如果项目未设置高度或设为auto，将占满整个容器的高度。（默认） |\n\n### 子元素属性\n\n**排序（order：<number>）**：排序，数值越小，越排前，默认为0\n\n**放大（flex-grow: <number>）**：放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）\n\n**缩小（flex-shrink:<number>）**：缩小：如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。\n\n**固定大小（flex-basis:<length> | auto）**:固定大小：默认为0，可以设置px值，也可以设置百分比大小\n\n**flex:none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]**：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。\n\n**单独对齐方式（align-self）**\n\n\n\n| 属性值        | 含义      |\n| ---------- | ------- |\n| auto       | 自动（默认）  |\n| flex-start | 顶部对齐    |\n| flex-end   | 底部对齐    |\n| center     | 居中对齐    |\n| baseline   | 文本基线对齐  |\n| stretch    | 上下对齐并铺满 |","tags":["css3"]}]